<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>1105 ì´ì„œì •</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      padding: 30px;
      background-color: #f7f7f7;
    }
    input, button {
      margin: 5px;
      padding: 5px;
      font-size: 16px;
    }
    .section {
      background: white;
      padding: 20px;
      margin-bottom: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h2 {
      color: #222;
    }
    .log {
        background: #f9f9f9;
        border: 1px solid #ccc;
        font-family: 'Courier New', 'Fira Code', monospace;
        font-size: 14px;
        line-height: 1.6;
        padding: 15px;
        margin-top: 15px;
        border-radius: 6px;
        white-space: pre-wrap;
        color: #222;
        }

  </style>
</head>
<body>

  <header style="text-align: center; margin-bottom: 40px;">
    <h1 style="font-size: 36px; margin: 0;">Hill ì•”í˜¸</h1>
    <p style="font-size: 18px; color: #555;">1105 ì´ì„œì •</p>
  </header>

  <div class="section">
    <h2>ğŸ” Hill ì•”í˜¸í™” (í•œê¸€)</h2>
    <input type="text" id="plaintext" placeholder="í‰ë¬¸ ì…ë ¥ (ì˜ˆ: ì•ˆë…•)">
    <br>
    í‚¤ í–‰ë ¬ (2Ã—2):<br>
    <input type="number" id="k00"> <input type="number" id="k01"><br>
    <input type="number" id="k10"> <input type="number" id="k11"><br>
    <button onclick="encrypt()">ì•”í˜¸í™”í•˜ê¸°</button>
    <p>
        <span id="ciphertextResult"></span>
        <button onclick="copyCiphertext()">ë³µì‚¬í•˜ê¸°</button>
    </p>
    <div class="log" id="encryptLog"></div>
  </div>

  <div class="section">
    <h2>ğŸ”“ Hill ë³µí˜¸í™” (í•œê¸€)</h2>
    <input type="text" id="ciphertext" placeholder="ì•”í˜¸ë¬¸ ì…ë ¥">
    <br>
    í‚¤ í–‰ë ¬ (2Ã—2):<br>
    <input type="number" id="dk00"> <input type="number" id="dk01"><br>
    <input type="number" id="dk10"> <input type="number" id="dk11"><br>
    <button onclick="decrypt()">ë³µí˜¸í™”í•˜ê¸°</button>
    <p id="plaintextResult"></p>
    <div class="log" id="decryptLog"></div>
  </div>

  <script>
    const charset = 'ã„±ã„²ã„´ã„·ã„¸ã„¹ã…ã…‚ã…ƒã……ã…†ã…‡ã…ˆã…‰ã…Šã…‹ã…Œã…ã…ã…ã…ã…‘ã…’ã…“ã…”ã…•ã…–ã…—ã…˜ã…™ã…šã…›ã…œã…ã…ã…Ÿã… ã…¡ã…¢ã…£*';
    const charMap = {};
    charset.split('').forEach((ch, i) => { charMap[ch] = i; });
    const indexToChar = i => (i >= 0 && i < charset.length) ? charset[i] : '?';

    function mod(n, m) {
      return ((n % m) + m) % m;
    }

    function gcd(a, b) {
      while (b !== 0) {
        let t = b;
        b = a % b;
        a = t;
      }
      return a;
    }

    function modularInverse(a, m) {
      for (let i = 1; i < m; i++) {
        if (mod(a * i, m) === 1) return i;
      }
      return null;
    }

    function invertMatrix2x2(m, modn) {
      const det = mod(m[0][0]*m[1][1] - m[0][1]*m[1][0], modn);
      if (gcd(det, modn) !== 1) return null;
      const detInv = modularInverse(det, modn);
      if (detInv === null) return null;
      return [
        [mod(m[1][1] * detInv, modn), mod(-m[0][1] * detInv, modn)],
        [mod(-m[1][0] * detInv, modn), mod(m[0][0] * detInv, modn)]
      ];
    }

    function getMatrix(prefix) {
      const get = id => {
        const val = parseInt(document.getElementById(id).value);
        return isNaN(val) ? 0 : val;
      };
      return [
        [get(prefix + '00'), get(prefix + '01')],
        [get(prefix + '10'), get(prefix + '11')]
      ];
    }

    function hangulToJamo(str) {
        const result = [];
        for (let ch of str) {
        const code = ch.charCodeAt(0) - 44032;
        if (code < 0 || code > 11171) continue;
        const chosung = Math.floor(code / 588);
        const jungsung = Math.floor((code % 588) / 28);
        const jongsung = code % 28;
        const CHOSUNG = ['ã„±','ã„²','ã„´','ã„·','ã„¸','ã„¹','ã…','ã…‚','ã…ƒ','ã……','ã…†','ã…‡','ã…ˆ','ã…‰','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
        const JUNGSUNG = ['ã…','ã…','ã…‘','ã…’','ã…“','ã…”','ã…•','ã…–','ã…—','ã…˜','ã…™','ã…š','ã…›','ã…œ','ã…','ã…','ã…Ÿ','ã… ','ã…¡','ã…¢','ã…£'];
        const JONGSUNG = ['', 'ã„±','ã„²','ã„³','ã„´','ã„µ','ã„¶','ã„·','ã„¹','ã„º','ã„»','ã„¼','ã„½','ã„¾','ã„¿','ã…€','ã…','ã…‚','ã…„','ã……','ã…†','ã…‡','ã…ˆ','ã…Š','ã…‹','ã…Œ','ã…','ã…'];
        result.push(CHOSUNG[chosung]);
        result.push(JUNGSUNG[jungsung]);
        if (jongsung !== 0) result.push(JONGSUNG[jongsung]);
        }
    return result;
    }

    function encrypt() {
      const log = [];
      const raw = document.getElementById('plaintext').value;
      const jamoText = hangulToJamo(raw);
      const vec = jamoText.map(ch => {
        if (!(ch in charMap)) return -1;
        return charMap[ch];
      });
    if (vec.includes(-1)) {
        document.getElementById('ciphertextResult').innerText = 'â— ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¬¸ìê°€ ìˆìŠµë‹ˆë‹¤.';
        return;
    }

    // âœ… íŒ¨ë”©ì€ ì§ìˆ˜ ë§ì¶”ê¸° ìœ„í•´ ì¶”ê°€í•´ì•¼ í•¨ (ì•”í˜¸í™” ì „ìš©)
    if (vec.length % 2 !== 0) {
        vec.push(charMap['*'])
        log.push('[íŒ¨ë”©] í™€ìˆ˜ ê¸¸ì´ â†’ * ì¶”ê°€ë¨');
    }

      const key = getMatrix('k');
      const det = mod(key[0][0]*key[1][1] - key[0][1]*key[1][0], charset.length);
      if (gcd(det, charset.length) !== 1) {
        document.getElementById('ciphertextResult').innerText = 'â— ì•”í˜¸í™” ë¶ˆê°€: í‚¤ í–‰ë ¬ì‹ì´ ë¬¸ì ê°œìˆ˜ì™€ ì„œë¡œì†Œê°€ ì•„ë‹™ë‹ˆë‹¤.';
        return;
      }

      const result = [];
      for (let i = 0; i < vec.length; i += 2) {
        const p = [vec[i], vec[i+1]];
        const c = [
          mod(key[0][0]*p[0] + key[0][1]*p[1], charset.length),
          mod(key[1][0]*p[0] + key[1][1]*p[1], charset.length)
        ];
        result.push(...c);
        log.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        log.push('');
        log.push(`[ ì…ë ¥ ë¬¸ììŒ ] ${indexToChar(p[0])}${indexToChar(p[1])}`);
        log.push(`- ë¬¸ì ì¸ë±ìŠ¤: ${indexToChar(p[0])}=${p[0]}, ${indexToChar(p[1])}=${p[1]}`);
        log.push(`- í‰ë¬¸ ë²¡í„°: [ ${p[0].toString().padStart(2)} ]`);
        log.push(`            [ ${p[1].toString().padStart(2)} ]`);
        log.push('');
        log.push(` - í–‰ë ¬ê³±`);
        log.push(`[ ${key[0][0]}  ${key[0][1]} ]     [ ${p[0]} ]   =   [ ${key[0][0]}Ã—${p[0]} + ${key[0][1]}Ã—${p[1]} = ${key[0][0]*p[0] + key[0][1]*p[1]} ]   â†’ mod ${charset.length} = ${c[0]} â†’ ${indexToChar(c[0])}`);
        log.push(`[ ${key[1][0]}  ${key[1][1]} ]  Ã—  [ ${p[1]} ]       [ ${key[1][0]}Ã—${p[0]} + ${key[1][1]}Ã—${p[1]} = ${key[1][0]*p[0] + key[1][1]*p[1]} ]  â†’ mod ${charset.length} = ${c[1]} â†’ ${indexToChar(c[1])}`);
        log.push('');
        log.push(`[ ì•”í˜¸í™”ëœ ë¬¸ììŒ ] ${indexToChar(c[0])}${indexToChar(c[1])}`);
        log.push('');
      }
      const cipherText = result.map(indexToChar).join('');
      document.getElementById('ciphertextResult').innerText = 'ì•”í˜¸ë¬¸: ' + cipherText;
      document.getElementById('encryptLog').innerText = log.join('\n');
    }

    function decrypt() {
      const log = [];
      const input = document.getElementById('ciphertext').value;
      const vec = input.split('').map(ch => {
        if (!(ch in charMap)) return -1;
        return charMap[ch];
      });
      if (vec.includes(-1)) {
        document.getElementById('plaintextResult').innerText = 'â— ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¬¸ìê°€ ìˆìŠµë‹ˆë‹¤.';
        return;
      }
      if (vec.length % 2 !== 0) {
        document.getElementById('plaintextResult').innerText = 'â— ì§ìˆ˜ ê°œ ë¬¸ì ì…ë ¥ í•„ìš”';
        return;
      }
      const key = getMatrix('dk');
      const inv = invertMatrix2x2(key, charset.length);
      const det = mod(key[0][0]*key[1][1] - key[0][1]*key[1][0], charset.length);
      const detInv = modularInverse(det, charset.length);

      log.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      log.push('');
      log.push('[ í–‰ë ¬ì‹(det) ]');
      log.push(`det = (${key[0][0]}Ã—${key[1][1]})âˆ’(${key[0][1]}Ã—${key[1][0]}) = ${key[0][0]*key[1][1]}âˆ’${key[0][1]*key[1][0]} = ${key[0][0]*key[1][1] - key[0][1]*key[1][0]}`);
      log.push('');
      log.push('[ í‚¤ í–‰ë ¬ì˜ ì—­í–‰ë ¬ ]');
      log.push(`            [ ${key[1][1]} ${-key[0][1]} ]      [ ${key[1][1]*detInv} ${-key[0][1]*detInv} ]   â†’ mod ${charset.length} = [ ${mod(key[1][1]*detInv, charset.length)} ${mod(-key[0][1]*detInv, charset.length)} ]`);
      log.push(`A^-1 = ${detInv} x [ ${-key[1][0]} ${key[0][0]} ]  =  [ ${-key[1][0]*detInv} ${key[0][0]*detInv} ]  â†’ mod ${charset.length} = [ ${mod(-key[1][0]*detInv, charset.length)} ${mod(key[0][0]*detInv, charset.length)} ]`);
      log.push('');
      log.push('');
      if (!inv) {
        document.getElementById('plaintextResult').innerText = 'â— ë³µí˜¸í™” ë¶ˆê°€: ì—­í–‰ë ¬ ì—†ìŒ';
        return;
      }
      const result = [];
      for (let i = 0; i < vec.length; i += 2) {
        const c = [vec[i], vec[i+1]];
  
        // âœ… ë³€ìˆ˜ ì„ ì–¸  ì¶”ê°€
        const x = c[0], y = c[1];
        const k00 = inv[0][0], k01 = inv[0][1];
        const k10 = inv[1][0], k11 = inv[1][1];

        const r0 = k00 * x + k01 * y;
        const r1 = k10 * x + k11 * y;
        const m0 = mod(r0, charset.length);
        const m1 = mod(r1, charset.length);
        result.push(m0, m1);

        // â–¶ ì•„ë˜ëŠ” ìš°ë¦¬ê°€ ë§ì¶˜ í¬ë§·
        log.push('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        log.push('');
        log.push(`[ ì•”í˜¸ ë¬¸ììŒ ] ${indexToChar(x)}${indexToChar(y)}`);
        log.push(`- ë¬¸ì ì¸ë±ìŠ¤: ${indexToChar(x)}=${x}, ${indexToChar(y)}=${y}`);
        log.push(`- í‰ë¬¸ ë²¡í„°: [ ${x.toString().padStart(2)} ]`);
        log.push(`            [ ${y.toString().padStart(2)} ]`);
        log.push('');
        log.push(` - ì—­í–‰ë ¬ ê³±`);
        log.push(`[ ${k00}  ${k01} ]     [ ${x} ]   =   [ ${k00}Ã—${x} + ${k01}Ã—${y} = ${r0} ]   â†’ mod ${charset.length} = ${m0} â†’ ${indexToChar(m0)}`);
        log.push(`[ ${k10}  ${k11} ]  Ã—  [ ${y} ]       [ ${k10}Ã—${x} + ${k11}Ã—${y} = ${r1} ]  â†’ mod ${charset.length} = ${m1} â†’ ${indexToChar(m1)}`);
        log.push('');
        log.push(`[ ë³µí˜¸í™”ëœ ë¬¸ììŒ ] ${indexToChar(m0)}${indexToChar(m1)}`);
        log.push('');
      }

      const plainText = result.map(indexToChar).join('').replace(/\*+$/, '');
      document.getElementById('plaintextResult').innerText = 'ë³µí˜¸ë¬¸: ' + plainText;
      document.getElementById('decryptLog').innerText = log.join('\n');
    }

    function copyCiphertext() {
        const text = document.getElementById('ciphertextResult').innerText.replace(/^ì•”í˜¸ë¬¸:\s*/, '');
        if (!text) return alert('ë³µì‚¬í•  ì•”í˜¸ë¬¸ì´ ì—†ìŠµë‹ˆë‹¤.');
        navigator.clipboard.writeText(text).then(() => {
            alert('ì•”í˜¸ë¬¸ì´ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸ‰');
        }).catch(err => {
            alert('ë³µì‚¬ ì‹¤íŒ¨ ğŸ˜¥: ' + err);
        });
    }

  </script>

</body>
</html>